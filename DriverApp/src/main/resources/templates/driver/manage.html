<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <th:block th:replace="~{/include/headerbaseLayout}"/>
    <title>승하차관리페이지</title>
    <link rel="stylesheet" href="/css/driver/manage.css">
    <link rel="stylesheet" href="/css/child/childDetail.css">
    <script src="/js/driver/manage.js"></script>
    <script src="/js/driver/kakaoMap.js"></script>
    <script type="text/javascript" src="//dapi.kakao.com/v2/maps/sdk.js?appkey=8997d782f5298e9e818dbcbf6a5ab396&libraries=services"></script>
</head>
<body>
<th:block th:replace="~{/include/baseLayout :: setContent(~{ :: .app-content})}">

    <section class="app-content">
        <div class="content-header">
            <div class="backBtn"><img src="/img/back.png" alt="뒤로가기"></div>
            <div class="header-comment-wrap">
                <p class="header-mainComment">승하차관리</p>
                <p class="header-subComment">동대문구 1노선</p>
            </div>
        </div>



        <!-- 카카오맵 스크립트 추가 -->
        <script type="text/javascript"
                src="//dapi.kakao.com/v2/maps/sdk.js?appkey=${kakao.javascript.key}&libraries=services"></script>

        <!-- 지도 컨테이너 -->
        <div id="map" style="width:100%;height:250px;"></div>

        <!-- 경로 표시 스크립트 -->
        <script th:inline="javascript">
            /*<![CDATA[*/
            document.addEventListener('DOMContentLoaded', function() {

                let currentPolyline = null; // 현재 지도에 그려진 Polyline(경로 선) 객체를 저장. 새 경로를 그릴 때 기존 선을 지우기 위해 사용

                // 지도 초기화
                const mapContainer = document.getElementById('map');
                const mapOption = {
                    center: new kakao.maps.LatLng(37.5665, 126.9780), // 지도의 중심좌표(서울 시청 근처)
                    level: 5 // 지도 확대/축소 레벨 (숫자가 작을수록 확대)
                };
                const map = new kakao.maps.Map(mapContainer, mapOption); // 지도 객체 생성

                // 1. 마커를 관리할 배열
                let markers = []; // 지도에 표시된 모든 마커를 저장. 나중에 한 번에 지우거나 관리할 때 사용

                // 2. 모든 마커 지우기 함수
                function clearMarkers() {
                    // 배열에 저장된 모든 마커를 지도에서 제거
                    markers.forEach(marker => marker.setMap(null));
                    markers = []; // 배열 비우기
                }

                // 주소 → 좌표 변환 함수
                // 입력한 주소(또는 키워드)를 Kakao API로 좌표(x, y)로 변환
                function addressToCoords(address) {
                    return new Promise((resolve, reject) => {
                        const geocoder = new kakao.maps.services.Geocoder();
                        geocoder.addressSearch(address, function(result, status) {
                            if (status === kakao.maps.services.Status.OK && result.length > 0) {
                                resolve({ x: parseFloat(result[0].x), y: parseFloat(result[0].y) });
                            } else {
                                // 주소 변환 실패 시 키워드(장소명) 검색으로 재시도
                                const places = new kakao.maps.services.Places();
                                places.keywordSearch(address, function(result, status) {
                                    if (status === kakao.maps.services.Status.OK && result.length > 0) {
                                        resolve({ x: parseFloat(result[0].x), y: parseFloat(result[0].y) });
                                    } else {
                                        reject('주소 변환 실패: ' + address);
                                    }
                                });
                            }
                        });
                    });
                }


                // 3. 마커 생성 함수 (출발, 도착, 경유지에 따라 마커 이미지 다르게 표시)
                function addMarker(lat, lng, type) {
                    let imageSrc, imageSize, markerImage;
                    if (type === 'start') {
                        imageSrc = 'https://t1.daumcdn.net/localimg/localimages/07/mapapidoc/markerStar.png'; // 파란색(출발)
                    } else if (type === 'end') {
                        imageSrc = 'https://t1.daumcdn.net/localimg/localimages/07/mapapidoc/marker_red.png'; // 빨간색(도착)
                    } else {
                        imageSrc = 'https://t1.daumcdn.net/localimg/localimages/07/mapapidoc/marker_red.png'; // 초록색(경유)
                    }
                    imageSize = new kakao.maps.Size(24, 35); // 마커 이미지 크기 지정
                    markerImage = new kakao.maps.MarkerImage(imageSrc, imageSize);

                    const marker = new kakao.maps.Marker({
                        position: new kakao.maps.LatLng(lat, lng),
                        image: markerImage,
                        map: map
                    });
                    markers.push(marker); // 생성한 마커를 배열에 저장
                }

                // 경로 그리기(경유지 없이)
                function drawRoute(startX, startY, endX, endY) {
                    // 백엔드 API에서 경로 좌표 배열을 받아옴 (fetch: 비동기 통신)
                    //(POST 요청)
                    fetch('/api/map/route', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                startX: startX,
                                startY: startY,
                                endX: endX,
                                endY: endY,
                                waypoints: [] // 경유지가 없으면 빈 배열
                            })
                        })
                        .then(response => response.json())
                        .then(coordinates => {
                            if (currentPolyline) currentPolyline.setMap(null); // 기존 경로 선 제거
                            clearMarkers(); // 기존 마커 제거

                            const path = [];
                            // 좌표 배열을 Kakao LatLng 객체로 변환하여 경로(path) 생성
                            for(let i=0; i<coordinates.length; i+=2) {
                                path.push(new kakao.maps.LatLng(coordinates[i+1], coordinates[i]));
                            }
                            // Polyline(경로선) 생성 및 지도에 표시
                            currentPolyline = new kakao.maps.Polyline({
                                map: map,
                                path: path,
                                strokeWeight: 5,
                                strokeColor: '#FF00FF',
                                strokeOpacity: 0.7
                            });

                            // 경로 전체가 보이도록 지도 영역 조정
                            const bounds = new kakao.maps.LatLngBounds();
                            path.forEach(coord => bounds.extend(coord));
                            map.setBounds(bounds);

                            // 출발지, 도착지 마커 표시
                            if (path.length > 0) {
                                addMarker(path[0].getLat(), path[0].getLng(), 'start'); // 출발지
                                addMarker(path[path.length-1].getLat(), path[path.length-1].getLng(), 'end'); // 도착지
                            }
                        })
                        .catch(error => {
                            alert('경로를 불러오는데 실패했습니다.');
                            console.error(error);
                        });
                }

                // 경유지 포함 경로 그리기
                // 경로 그리기 함수
                async function drawRouteWithWaypoints() {
                    const startAddr = document.getElementById('startAddress').value;
                    const endAddr = document.getElementById('endAddress').value;
                    const waypoints = Array.from(document.querySelectorAll('.waypoint-input'))
                        .map(input => input.value.trim())
                        .filter(v => v);

                    try {
                        // 주소 → 좌표 변환
                        const start = await addressToCoords(startAddr);
                        const end = await addressToCoords(endAddr);
                        const waypointCoords = await Promise.all(
                            waypoints.map(addr => addressToCoords(addr))
                        );

                        // 백엔드 API 호출
                        const response = await fetch('/api/map/route', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                startX: start.x,
                                startY: start.y,
                                endX: end.x,
                                endY: end.y,
                                waypoints: waypointCoords.map(c => ({ x: c.x, y: c.y }))
                            })
                        });

                        const coordinates = await response.json();

                        // === 여기서 직접 경로 그리기 ===
                        if (currentPolyline) currentPolyline.setMap(null);
                        clearMarkers();

                        const path = [];
                        for (let i = 0; i < coordinates.length; i += 2) {
                            path.push(new kakao.maps.LatLng(coordinates[i + 1], coordinates[i]));
                        }
                        currentPolyline = new kakao.maps.Polyline({
                            map: map,
                            path: path,
                            strokeWeight: 5,
                            strokeColor: '#FF00FF',
                            strokeOpacity: 0.7
                        });
                        const bounds = new kakao.maps.LatLngBounds();
                        path.forEach(coord => bounds.extend(coord));
                        map.setBounds(bounds);

                        // 출발, 경유지, 도착 마커 표시
                        if (path.length > 0) {
                            addMarker(path[0].getLat(), path[0].getLng(), 'start');
                            waypointCoords.forEach(wp => addMarker(wp.y, wp.x, 'way'));
                            addMarker(path[path.length - 1].getLat(), path[path.length - 1].getLng(), 'end');
                        }

                    } catch (error) {
                        console.error('경로 생성 오류:', error);
                        alert('경로 생성에 실패했습니다.');
                    }
                }

                // 경로 그리기 버튼 클릭 이벤트
                document.getElementById('drawRouteBtn').addEventListener('click', async function() {
                    const startAddress = document.getElementById('startAddress').value.trim();
                    const endAddress = document.getElementById('endAddress').value.trim();
                    const waypoints = Array.from(document.querySelectorAll('.waypoint-input'))
                        .map(input => input.value.trim())
                        .filter(v => v);

                    if (!startAddress || !endAddress) {
                        alert('출발지와 도착지 주소를 모두 입력해주세요.');
                        return;
                    }

                    try {
                        const start = await addressToCoords(startAddress);
                        const end = await addressToCoords(endAddress);
                        const waypointCoords = await Promise.all(
                            waypoints.map(addr => addressToCoords(addr))
                        );

                        // 경유지 있을 때
                        if (waypointCoords.length > 0) {
                            drawRouteWithWaypoints(start.x, start.y, end.x, end.y, waypointCoords);
                        } else {
                            drawRoute(start.x, start.y, end.x, end.y);
                        }

                    } catch (error) {
                        alert(error);
                    }
                });


                // 경유지 추가 버튼 이벤트
                document.getElementById('addWaypointBtn').addEventListener('click', () => {
                    const container = document.getElementById('waypointContainer');
                    if (container.children.length >= 30) {
                        alert('최대 30개까지 추가 가능합니다.');
                        return;
                    }

                    const waypointDiv = document.createElement('div');
                    waypointDiv.className = 'waypoint-item';
                    waypointDiv.innerHTML = `
                        <input type="text" class="waypoint-input" placeholder="경유지 주소">
                        <button class="remove-waypoint">×</button>
                    `;
                    waypointDiv.querySelector('.remove-waypoint').addEventListener('click', () => {
                        container.removeChild(waypointDiv);
                    });
                    container.appendChild(waypointDiv);
                });

                // 기본 경로 표시(페이지 로딩 시)
                drawRoute(127.03041938929663, 37.50133927181133, 127.030515949937, 37.4996237314472);
            });
            /*]]>*/
        </script>
        출발지 도착지 입력

        <div style="margin-bottom:10px;">
            <input type="text" id="startAddress" placeholder="출발지 주소 입력" style="width:200px;">
            <div id="waypointContainer"></div>
            <button type="button" id="addWaypointBtn">+ 경유지 추가</button><br>
            <input type="text" id="endAddress" placeholder="도착지 주소 입력" style="width:200px;">
            <button id="drawRouteBtn">경로 그리기</button>
        </div>




        <!--승하차관련-->
        <div class="boarding-status"></div>
        <div class="list-card" th:each="child : ${childrenList}">
            <div class="list-box">
                <div class="list-img">
                    <img src="/img/child.png" alt="아이사진">
                </div>
                <div class="list-content">
                    <div th:text="${child.childName}">이름(나이)</div>
                    <div th:text="${child.userVO.userAddress+' '+child.userVO.userAddressDetail}">주소</div>
<!--                    <div th:text="'하차 시간 ' + (${child.dropoffTime} ?: '')">하차 시간 &#45;&#45;:&#45;&#45; </div>-->
                </div>
                <div th:class="'list-time' + (${child.dropState} == '하차완료' ? ' done' : '')"
                     th:text="${child.dropState} == '하차완료' ? '하차완료' : '하차'">하차</div>
            </div>

        </div>
        <div class="addModal modal">
            <div class="modal-content">
                <th:block th:replace="~{/child/childDetail}"></th:block>
            </div>
        </div>

        <div class>

        </div>


    </section>
</th:block>
</body>
</html>